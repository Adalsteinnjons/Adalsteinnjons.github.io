I"ˆ,<h1 id="high-level-overview-of-topics-first-lecture">High level overview of topics (First Lecture)</h1>

<p>We will focus on applying knowledge and develop intuition in algorithm design.<br />
Which techniques work for which problem?<br />
Important skills:</p>

<ul>
  <li>
    <p>Know your algorithms</p>
  </li>
  <li>
    <p>Know tools &amp; Libraries</p>
  </li>
  <li>
    <p>Creativity</p>
  </li>
  <li>
    <p>Problem Solving</p>
  </li>
  <li>
    <p>Time Management</p>
  </li>
  <li>
    <p>Testing</p>
  </li>
</ul>

<p><strong>Steps to solving a problem:</strong></p>

<ol>
  <li>
    <p>Read the problem</p>
  </li>
  <li>
    <p>Find the appropriate Model</p>
  </li>
  <li>
    <p>Design a suitable Algorithm</p>
  </li>
  <li>
    <p>Implement and test the algorithm on given data</p>
  </li>
</ol>

<p>All problems can be solved with &lt; 100 lines of code</p>

<h2 id="strategies">Strategies</h2>

<h3 id="brute-force">Brute Force</h3>

<p>Generate all possible solutions by trying out all the opposites. Then select the best one. This can be implemented using recursion or just looping though all possibilities.</p>

<h3 id="greedy">Greedy</h3>

<p>Always makes the choice that looks best at the moment. It never takes back its choices. The result a the end will be optimal if the choices are all independent of another. It is often difficult to prove that the locally optimal solution is also the global one. Example with giving back change, we want to give the least amount of coins back. Then always give the biggest possible until you have given all the money back. That works with euro money {1,2,5,10,50,100,200}, but not with every coin set.<br />
But with other sets it doesnâ€™t work. Example: Give 6 francs back and we have these types of coins: {1,3,4}, by using greedy we would give 4 + 1 + 1, but the optimal solution would have been 3 + 3. This disproves the greedy approach. We often can only proof that is doesnâ€™t work.</p>

<h3 id="divide--conquer">Divide &amp; Conquer</h3>

<p>Divide the problem into smaller problems until you can solve a small problem and build up from there. It is based on recursion. This technique is used for sorting (quicksort, mergesort), multiplying large numbers and finding the closes pair of points.</p>

<h3 id="dynamic-programming">Dynamic Programming</h3>

<p>Combines effectiveness of greedy with completeness of brute force/complete search. We divide the problem into sub-problems and solve them recursively storing their results. We can use DP to:</p>
<ul>
  <li>Find an optimal solution. As large or as small as possible</li>
  <li>Count total number of solutions<br />
You can do it either top down or bottom up.<br />
Bottom up: construct the table and the result is in the top right corner.
Top-down: Recursively with memoization</li>
</ul>

<h3 id="backtracking">Backtracking</h3>

<p>Typical algorithm to solve the 8 queens problem. It goes by the trial and error principle. Uses recursion in the algorithm. Tries out until it finds error, goes always a level deeper, when it find error it goes back and starts from where there was no error anymore.</p>

<h3 id="binary-search">Binary Search</h3>

<p>Normal for loop complexity: O(n)
If the array is sorted, with binary search we can search through it in O(log n) time.
Array has 100 Elements:
For loop: 100 loops <br />
Binary Search: 6.64 Loops <br />
1000 Elements<br />
For Loop: 1000 Loops <br />
Binary Search: 10 Loops<br />
10â€™000 Elements:<br />
For Loop 10â€™000 Loops<br />
Binary Search: 13.3 Loops<br />
1 Million Elements:<br />
Binary Search: 19.93 Loops<br />
Also possible to use in std::binary_search(v.begin(), v.end(), value) â€“&gt; returns true if found. Needs sorted vectors!</p>

<h2 id="data-structures">Data Structures</h2>

<h3 id="array">Array</h3>
<p>There are built in arrays, T[], but they should not be used. Instead use std::array. You need to include:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;array&gt;  
</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">5</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span>  
<span class="n">We</span> <span class="n">can</span> <span class="n">iterate</span> <span class="n">with</span> <span class="p">[</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">()]</span>  
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">AI</span><span class="p">;</span>  
<span class="n">AI</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">}</span>  
<span class="k">for</span> <span class="p">(</span><span class="n">AI</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>  <span class="c1">//This is if we dont want to chagne the contents in the loop, if we want to change we use AI::iterator instead.  </span>
<span class="n">But</span> <span class="n">even</span> <span class="n">better</span> <span class="n">just</span> <span class="n">use</span> <span class="o">**</span><span class="n">ranges</span><span class="o">**:</span>  
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">a</span><span class="p">){</span>  
  <span class="n">std</span><span class="o">::</span> <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre></div></div>

<h4 id="vectors">Vectors</h4>

<p>Like an array bot has no fixed length. We always use vectors. <br />
#include <vector>   
Insertion and deletion at the end is very fast, in constant time. But if we insert at beginning all elements have to be moved.   
std::vector<int> a(5)  
Size of vector: a.size()  
for( int i = 0; i &lt; a.size(); i++){    
&nbsp;&nbsp;&nbsp; cout &lt;&lt; a.at(i) &lt;&lt; " ";  
}</int></vector></p>

<p><strong>2D Vector</strong><br />
typedef vector<int> VI;  
typedef vector<VI> VII;
Now we have a vector of int vectors. That means a 2D Matrix.  
int n = 100;  m  = 50;  
VII = (10, VI(10, -1)) //10 x 10 matrix with all elements set to -1</VI></int></p>

<h3 id="stack">Stack</h3>

<p>std::stack<br />
FILO data structure<br />
stack<int> s;  
s.push(17);  
int top = s.top();
s.pop();  
This is useful for graph algorithms, particularly for iterative implementation of DFS.</int></p>

<h3 id="set">Set</h3>

<p>A set of unique objects. You can find an object iterator with set.find(3), only has O(log n) complexity.</p>

<h3 id="queue">Queue</h3>

<p>FIFO<br />
queue<int>q;
q.push(17);  
int front = q.front();  
int back = q.back();  
q.pop()  
This one is useful when implementing BFS.</int></p>

<h3 id="tree">Tree</h3>

<p>Just create the structure yourself with structs. Most important the binary tree.</p>

<h3 id="heap">Heap</h3>

<p>Similar to a binary search tree but has faster insertion. Immediate insertion O(1). For BST its O(log(n)).  A BST is faster searching. Only log n while heap has n</p>

<h3 id="hash-table">Hash-table</h3>

<p>A table where you can store values. It hashes the values and stores them. If you want to search for an item that takes O(1) time since you only need to hash the key to get the correct index. <br />
Simple implementation of a hash function: <br />
<img src="http://i.imgur.com/8HfRVKy.png" alt="hashtable" /></p>

<h2 id="graph-algorithms">Graph Algorithms</h2>

<h3 id="dfs">DFS</h3>

<p>Start at the starting node. Then follow the next node and stay on that path until you cant go further, then go back to last node where you can go another path.</p>

<h3 id="bfs">BFS</h3>

<p>Start at starting node, then visit closest node. It always visits the closest node to it. Goes through the nodes one level after another.</p>

<h3 id="mst">MST</h3>

<p>Is a subset of the edges of a connected, edge-weighted graph that connects all the certices together without cycles and with minimum possible weight. 
<img src="http://i.imgur.com/Dyg8mRh.png" alt="mst" /></p>

<h3 id="dijkstra">Dijkstra</h3>

<p>To find the shortest path to every node</p>

<h2 id="graph-concepts">Graph Concepts</h2>

<h3 id="directed-graph">Directed Graph</h3>

<p>A graph with edges as arrows</p>

<h3 id="coloring">Coloring</h3>

<p>Each node in a graph gets a color so no neighboring node has the same color. A graph is bipartite if it is possible to use just 2 colors. If a Graph has a cycle with an odd number of nodes, then it canâ€™t be colored using only 2 colors so it is not bipartite. <br />
Every single Map can be colored using just 4 colors. E.g. the chrome logo.</p>

<h3 id="matching">Matching</h3>

<p>No 2 edges should have the same node. Maximal matching: Set of edges so that each node is connected once.   <img src="http://i.imgur.com/i4cM8Co.png" alt="Maximal matching" />   Maximum matching: Matching that contains the larges possible number of edges. Every maximum matching is maximal. There are a lot more maximal matchings that there are maximum matchings.   <img src="http://i.imgur.com/qL1oRlo.png" alt="Maximum matching" /><br />
Perfect matching: A matching which matches all vertices of the graph. Every vertex of the graph is incident to exactly one edge of the matching. In the image above only (b) shows perfect matching.</p>

<h3 id="topological-sorting">Topological sorting</h3>

<p>Only possible if the graph is Directed Acyclic Graph (DAG). That means with arrows and no cycles. Topological sorting is a linear ordering of vertices such that for every directed edge uv, vertex u comes before v in the ordering. This is to traverse a graph, similar to DFS but not quite. So the vertexes with edges out of it come first, then the ones below.<br />
<img src="http://i.imgur.com/Cknly69.png" alt="" /></p>

<p>It is used in Task Scheduling or in pre-requisite problems.</p>

<h3 id="strongly-connected-components">(Strongly) connected Components</h3>

<p>A directed graph is strongly connected if there is a path between all pairs of vertices. So all are reachable from every vertex.</p>

:ET