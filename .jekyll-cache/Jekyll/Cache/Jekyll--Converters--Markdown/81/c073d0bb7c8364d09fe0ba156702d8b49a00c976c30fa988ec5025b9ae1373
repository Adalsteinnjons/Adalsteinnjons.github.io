I"b<h1 id="week-4">Week 4</h1>

<h2 id="ind-cpa-security-for-symmetric-encryption">IND-CPA security for Symmetric Encryption</h2>

<p><img src="https://i.imgur.com/IyJBJZZ.png" alt="IND-CPA" /></p>

<p>Doesn’t model integrity among other things.</p>

<h2 id="prp-prf-switching-lemma">PRP-PRF Switching Lemma</h2>

<p>This is PRP security:</p>

<p><img src="https://i.imgur.com/S65lMkX.png" alt="PRP sec" /></p>

<p>PRF security: distinguish between random key and a random function.<br />
PRP security: distinguis between random key and random permutaiton.<br />
A function is not a permutation, but a permutation is a function.</p>

<p>This is PRF security:</p>

<p><img src="https://i.imgur.com/8Jtu0E2.png" alt="PRF" /></p>

<p>If the input is the same as from previous values, then output the same as then, if not then choose new function. <strong>Did not get this fully</strong>.</p>

<p>Lemma:<br />
The absolute difference between these definitions is q<sup>2</sup>/2<sup>n+2</sup>.<br />
(The “+2” is from the advantage definition to normalize so it goes from 0 to 1)</p>

<p><img src="https://i.imgur.com/C6E870p.png" alt="gjemli" /></p>

<p>Pr[b=0] = 1/2<br />
Pr[b=1] = 1/2<br />
Pr[b’=1|b=0] = probability that b’=1, given that b=0</p>

<p><img src="http://i.imgur.com/SsUZuDN.png" alt="proof" /></p>

<p>Proof of PRF switching lemma:</p>

<p><img src="https://i.imgur.com/z6AcDyd.png" alt="proof" /></p>

<p><img src="https://i.imgur.com/LgdN3Hb.png" alt="proof2" /></p>

<p>Both games together: (Always the same except a repeated value occurs in G2 as Yi)</p>

<p><img src="https://i.imgur.com/63mVMUX.png" alt="proof" /></p>

<p><img src="https://i.imgur.com/Osdvbxh.png" alt="proof" /></p>

<h2 id="difference-lemma">Difference Lemma</h2>

<p><img src="https://i.imgur.com/4zzzb0y.png" alt="difference lemma" /></p>

<h2 id="complete-the-switching-lemma-proof">Complete the switching lemma proof</h2>

<p><img src="https://i.imgur.com/wDEex5P.png" alt="proof" /></p>

<p>These 2 lemmas occur again and again and again so try to understand it.</p>

<h2 id="proof-of-security-for-ctr-mode">Proof of Security for CTR mode</h2>

<h3 id="ind-cpa-security-for-ctr-mode-g0">IND-CPA security for CTR mode: G0</h3>

<p><img src="https://i.imgur.com/v4EhVWP.png" alt="cpasec" /></p>

<h3 id="ind-cpa-security-for-ctr-mode-g1">IND-CPA security for CTR mode: G1</h3>

<p><img src="http://i.imgur.com/rVopVZu.png" alt="cpasec" /></p>

<p>This is no longer using a block cipher, he is using a random permutation. The adversary can’t tell a difference between game G0 and G1. Any adversary that could, he could then distinguish the block cipher from a random permutation, that would break the security, that is not possible.</p>

<h3 id="ind-cpa-security-for-ctr-mode-g2">IND-CPA security for CTR mode: G2</h3>

<p><img src="https://i.imgur.com/b7De2n4.png" alt="cpasec" /></p>

<p>Here we change the random permutation with a random function.</p>

<h3 id="ind-cpa-security-for-ctr-mode-g3">IND-CPA security for CTR mode: G3</h3>

<p><img src="https://i.imgur.com/5oLV3A3.png" alt="cpasec" /></p>

<p>Here the advantage of the adversary is 0. This is essentially a one-time pad.<br />
As long as there is no repeating counter value between G2 and G3, then they are equal (can’t tell them apart).</p>

<p>Intuition of the images:</p>

<ul>
  <li>
    <p>The proof involves a sequence of games G 0 , … , G 3 .</p>
  </li>
  <li>
    <p>Each game is played between a fixed IND-CPA adversary A and a
challenger.</p>
  </li>
  <li>
    <p>We change the operation of the challenger slightly as we transition
between different pairs of games.</p>
  </li>
  <li>
    <p>In G 0 , the challenger is just the normal IND-CPA challenger for CTR mode.</p>
  </li>
  <li>
    <p>In G 3 , the challenger uses one-time pad encryption, so A’s advantage is zero.</p>
  </li>
  <li>
    <p>We show that in each transition, A’s advantage cannot change much.</p>
  </li>
  <li>
    <p>Since the advantage is zero in G 3 , the advantage in G 0 must be small.</p>
  </li>
  <li>
    <p>We will formalise this intuition and be concrete about “small”.</p>
  </li>
</ul>

<h3 id="formal-proof">Formal proof</h3>

<p><img src="https://i.imgur.com/V33U2U5.png" alt="proof" /></p>

<h3 id="bounding-p0---p1">bounding |p0 - p1|</h3>

<p><img src="https://i.imgur.com/Il8bJSc.png" alt="img" /></p>

<p>The IND-CPA challenger outsources the ciphertext it needs to encrypt a message to the PRP challenger C.</p>

<p>If d = 1 in the PRP challenger, then its the same game as G1. Because it just does a random permutation.</p>

<p>The challenger doesn’t use its key. The keyGen is in the Challenger C, it isn’t on the slides but it should be there.<br />
He uses the key for the encryption.</p>

<p><img src="https://i.imgur.com/aOFdnge.png" alt="text" /></p>

<p><img src="https://i.imgur.com/77hPKk5.png" alt="sdaf" /></p>

<h3 id="bounding-p1---p2">Bounding |p1 - p2|</h3>

<p><img src="https://i.imgur.com/ereAnzS.png" alt="ad" /></p>

<p><img src="https://i.imgur.com/PKmlGpY.png" alt="ads" /></p>

<p><img src="https://i.imgur.com/G0Y2rU9.png" alt="asd" /></p>

<h3 id="bounding-p2---p3">Bounding |p2 - p3|</h3>

<p>When d is 0, we are in game G2.
When d is 1, we are in game G3.</p>

<p><img src="https://i.imgur.com/zpiiSxh.png" alt="ad" /></p>

<p>The probability of Z is very small, the counter values are chosen uniformly at random. So to get a value twice is very unlikely.</p>

<p><img src="https://i.imgur.com/EvdjmJt.png" alt="gamli" /></p>

<h3 id="combining-everything">Combining everything</h3>

<p><img src="https://i.imgur.com/oBZK3p3.png" alt="ok" /></p>

<h2 id="lecture-10">Lecture 10</h2>

<ul>
  <li>
    <p>Padding and padding oreacle attacks</p>
  </li>
  <li>
    <p>Attacks on CBC mode with non-random IV</p>
  </li>
</ul>

<h2 id="padding">Padding</h2>

<p>Applies an injective map pad() to messages prior to CBC mode encryption, remove padding after decryption.</p>

<p>If the message was already block length. We need to add a complete block that is only padding. That block is 16 copies of OXOF. 16 because the block size in AES is 128 bits which is 16 bytes.</p>

<p>If the padding would be wrong, then the server could send a error message “bad padding”. The padding could be incorrectly formated because an adversary changes something.<br />
That opens the door to a padding oracle attack.</p>

<p><img src="https://i.imgur.com/IkNbPYT.png" alt="padding" /></p>

<p><img src="https://i.imgur.com/RMm27yZ.png" alt="blocks" /></p>

<p>The target block could be any block from the ciphertext. Doesn’t necessarily have to be the last block. C(t) does not have to be the last block in the ciphertext.</p>

<p><img src="https://i.imgur.com/FvpzpLA.png" alt="poodle" /></p>

<p>We need to get 0x00, that means padding is valid. By chance we could also hit 0x01, 0x01 in the last 2 or 0x02, 0x02, 0x02 in the last three. But that is highly unlikely and we could check that with one more query.</p>

<p><img src="https://i.imgur.com/lf5JPb9.png" alt="poodle" /></p>

<p>Then we continue from there, set the last byte to 0x01 and change the second last byte until you get “valid”, which means you have recovered 2 bytes.</p>

<p>Worst case cost of this attack: 256 queries to the oracle for each byte you want to recover.</p>

<p>This is a plaintext recovery attack, not a key recovery attack.</p>

<p><a href="https://robertheaton.com/2013/07/29/padding-oracle-attack/">Good explanation</a></p>
:ET